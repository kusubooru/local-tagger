// +build ignore

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"text/template"

	"github.com/kusubooru/tagaa/split"
)

const (
	kusubooruIcoPath = "generate/kusubooru.ico"
	danbooruIcoPath  = "generate/danbooru.ico"
	out              = "favicons.go"
)

var faviconsTemplate = `// generated by go generate; DO NOT EDIT

package main

var (
	kusubooruIcoBytes = []byte {
		{{.Kusubooru}}
	}

	danbooruIcoBytes = []byte {
		{{.Danbooru}}
	}
)
`

var faviconsTmpl = template.Must(template.New("faviconsTemplate").Parse(faviconsTemplate))

func main() {
	if err := generateFavicons(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

type FaviconData struct {
	Kusubooru string
	Danbooru  string
}

func readFavicons() (*FaviconData, error) {
	kf, err := os.Open(kusubooruIcoPath)
	if err != nil {
		return nil, err
	}
	kbytes, err := ioutil.ReadAll(kf)
	if err != nil {
		return nil, err
	}
	df, err := os.Open(danbooruIcoPath)
	if err != nil {
		return nil, err
	}
	dbytes, err := ioutil.ReadAll(df)
	if err != nil {
		return nil, err
	}
	data := &FaviconData{
		Kusubooru: bytesfmt(kbytes, byteColumns),
		Danbooru:  bytesfmt(dbytes, byteColumns),
	}
	return data, nil
}

const byteColumns = 16

func generateFavicons() error {
	favicon, err := readFavicons()
	if err != nil {
		return err
	}
	outf, err := os.Create(out)
	if err != nil {
		return err
	}
	defer func() {
		if cerr := outf.Close(); err == nil {
			err = cerr
		}
	}()

	err = faviconsTmpl.Execute(outf, favicon)
	if err != nil {
		return err
	}

	cmd := exec.Command("gofmt", "-w", out)
	err = cmd.Run()
	if err != nil {
		return err
	}
	return err
}

func bytesfmt(data []byte, n int) string {
	var buffer bytes.Buffer

	data2d := split.Bytes(data, n)

	for _, row := range data2d {
		for _, b := range row {
			buffer.WriteString(fmt.Sprintf("%v, ", b))
		}
		buffer.WriteString("\n")
	}

	return fmt.Sprintf(buffer.String())
}
